import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import html2canvas from 'html2canvas';

// Types for export data
interface ExportRow {
  [key: string]: string | number | null;
}

// Export to CSV
export const exportToCSV = (data: ExportRow[], filename: string) => {
  if (data.length === 0) return;
  
  const headers = Object.keys(data[0]);
  const csvContent = [
    headers.join(','),
    ...data.map(row => 
      headers.map(header => {
        const value = row[header];
        // Escape quotes and wrap in quotes if contains comma
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value ?? '';
      }).join(',')
    )
  ].join('\n');

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  saveAs(blob, `${filename}.csv`);
};

// Export to Excel
export const exportToExcel = (data: ExportRow[], filename: string, sheetName: string = 'Data') => {
  const worksheet = XLSX.utils.json_to_sheet(data);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  
  // Auto-size columns
  const maxWidths: number[] = [];
  const headers = Object.keys(data[0] || {});
  headers.forEach((header, i) => {
    maxWidths[i] = header.length;
    data.forEach(row => {
      const cellValue = String(row[header] ?? '');
      if (cellValue.length > maxWidths[i]) {
        maxWidths[i] = cellValue.length;
      }
    });
  });
  worksheet['!cols'] = maxWidths.map(w => ({ wch: Math.min(w + 2, 50) }));

  XLSX.writeFile(workbook, `${filename}.xlsx`);
};

// Export to PDF
export const exportToPDF = (
  data: ExportRow[], 
  filename: string, 
  title: string,
  subtitle?: string
) => {
  const doc = new jsPDF('landscape');
  
  // Add title
  doc.setFontSize(18);
  doc.setTextColor(0, 255, 255);
  doc.text(title, 14, 20);
  
  if (subtitle) {
    doc.setFontSize(10);
    doc.setTextColor(128, 128, 128);
    doc.text(subtitle, 14, 28);
  }

  // Prepare table data
  const headers = Object.keys(data[0] || {});
  const rows = data.map(row => headers.map(h => String(row[h] ?? '')));

  // Add table
  autoTable(doc, {
    head: [headers],
    body: rows,
    startY: subtitle ? 35 : 30,
    styles: {
      fontSize: 8,
      cellPadding: 3,
      textColor: [255, 255, 255],
      fillColor: [30, 30, 50],
    },
    headStyles: {
      fillColor: [0, 100, 100],
      textColor: [0, 255, 255],
      fontStyle: 'bold',
    },
    alternateRowStyles: {
      fillColor: [40, 40, 60],
    },
    theme: 'grid',
  });

  // Add footer
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(128, 128, 128);
    doc.text(
      `Generated by Algo Account Ability - Page ${i} of ${pageCount}`,
      doc.internal.pageSize.getWidth() / 2,
      doc.internal.pageSize.getHeight() - 10,
      { align: 'center' }
    );
  }

  doc.save(`${filename}.pdf`);
};

// Export element to PNG
export const exportToPNG = async (elementId: string, filename: string) => {
  const element = document.getElementById(elementId);
  if (!element) {
    console.error(`Element with id "${elementId}" not found`);
    return;
  }

  try {
    // Hide download bar, filter bar, purpose banner, and cross-check section during capture
    const downloadBars = element.querySelectorAll('.download-bar');
    const filterBars = element.querySelectorAll('.obs-filter-bar');
    const purposeBanners = element.querySelectorAll('.purpose-banner');
    const exportTitles = element.querySelectorAll('.png-export-title');
    const crossCheckSections = element.querySelectorAll('.cross-check-section');

    // Find all scrollable containers that might hide content
    const scrollContainers = element.querySelectorAll('.table-scroll-wrapper, .data-table-container');

    // Store original styles to restore later
    const originalStyles = {
      elementOverflow: element.style.overflow,
      elementWidth: element.style.width,
      elementMaxWidth: element.style.maxWidth,
      containerStyles: Array.from(scrollContainers).map(container => ({
        overflow: (container as HTMLElement).style.overflow,
        maxWidth: (container as HTMLElement).style.maxWidth,
        width: (container as HTMLElement).style.width,
      })),
    };

    downloadBars.forEach(bar => {
      (bar as HTMLElement).style.display = 'none';
    });
    filterBars.forEach(bar => {
      (bar as HTMLElement).style.display = 'none';
    });
    purposeBanners.forEach(banner => {
      (banner as HTMLElement).style.display = 'none';
    });
    crossCheckSections.forEach(section => {
      (section as HTMLElement).style.display = 'none';
    });
    // Show the export title during capture
    exportTitles.forEach(title => {
      (title as HTMLElement).style.display = 'block';
    });

    // Temporarily remove overflow restrictions to capture full width
    element.style.overflow = 'visible';
    element.style.width = 'auto';
    element.style.maxWidth = 'none';

    // Remove overflow from scroll containers
    scrollContainers.forEach(container => {
      (container as HTMLElement).style.overflow = 'visible';
      (container as HTMLElement).style.maxWidth = 'none';
      (container as HTMLElement).style.width = 'auto';
    });

    // Wait for layout to update
    await new Promise(resolve => setTimeout(resolve, 100));

    // Calculate the actual full width needed by checking the table's bounding box
    const table = element.querySelector('table');
    const tableWidth = table ? table.getBoundingClientRect().width : 0;

    // Use the actual content width to fit all columns
    const captureWidth = Math.max(
      tableWidth + 100, // Add padding for full table
      element.scrollWidth,
      table ? table.scrollWidth + 100 : 0,
      1600 // Minimum width for tables with many columns
    );

    const canvas = await html2canvas(element, {
      backgroundColor: '#1a1a2e',
      scale: 1.5, // Reduced from 2 to allow larger capture area while maintaining quality
      logging: false,
      useCORS: true,
      scrollY: -window.scrollY,
      scrollX: -window.scrollX,
      windowWidth: captureWidth,
      windowHeight: element.scrollHeight,
    });

    // Restore original styles
    element.style.overflow = originalStyles.elementOverflow;
    element.style.width = originalStyles.elementWidth;
    element.style.maxWidth = originalStyles.elementMaxWidth;

    // Restore scroll container styles
    scrollContainers.forEach((container, index) => {
      const styles = originalStyles.containerStyles[index];
      (container as HTMLElement).style.overflow = styles.overflow;
      (container as HTMLElement).style.maxWidth = styles.maxWidth;
      (container as HTMLElement).style.width = styles.width;
    });

    // Restore visibility
    downloadBars.forEach(bar => {
      (bar as HTMLElement).style.display = '';
    });
    filterBars.forEach(bar => {
      (bar as HTMLElement).style.display = '';
    });
    purposeBanners.forEach(banner => {
      (banner as HTMLElement).style.display = '';
    });
    crossCheckSections.forEach(section => {
      (section as HTMLElement).style.display = '';
    });
    exportTitles.forEach(title => {
      (title as HTMLElement).style.display = '';
    });

    canvas.toBlob((blob) => {
      if (blob) {
        saveAs(blob, `${filename}.png`);
      }
    });
  } catch (error) {
    console.error('Failed to export PNG:', error);
  }
};

// Format summary reports for export
export const formatSummaryReportsForExport = (reports: Array<{
  reportNumber: number;
  period: string;
  duration: string;
  reportDate: string;
  algoDistributed: number;
  fiatUSD: number | null;
  balanceSheet: string;
}>) => {
  return reports.map(report => ({
    'Report #': report.reportNumber,
    'Period': report.period,
    'Duration': report.duration,
    'Report Date': report.reportDate,
    'ALGO Distributed': report.algoDistributed.toLocaleString(),
    'Fiat (USD)': report.fiatUSD ? `$${report.fiatUSD.toLocaleString()}` : 'N/R',
    'Balance Sheet': report.balanceSheet,
  }));
};

// Format flags for export
export const formatFlagsForExport = (flags: Array<{
  issueNum: number;
  category: string;
  description: string;
  severity: string;
}>) => {
  return flags.map(flag => ({
    'Issue #': flag.issueNum,
    'Category': flag.category,
    'Description': flag.description,
    'Severity': flag.severity,
  }));
};

// Format key observations for export
export const formatKeyObservationsForExport = (observations: Array<{
  reportNumber: number;
  period: string;
  observations: Array<{ text: string; isHighlight?: boolean; isWarning?: boolean; isNew?: boolean }>;
}>) => {
  const rows: Array<{ 'Report #': number; 'Period': string; 'Observation': string; 'Type': string }> = [];
  observations.forEach(report => {
    report.observations.forEach(obs => {
      let type = 'Normal';
      if (obs.isHighlight) type = 'Highlight';
      if (obs.isWarning) type = 'Warning';
      if (obs.isNew) type = 'New';
      rows.push({
        'Report #': report.reportNumber,
        'Period': report.period,
        'Observation': obs.text,
        'Type': type,
      });
    });
  });
  return rows;
};
